# -*- coding: utf-8 -*-
"""Disaster_Allocator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dfCO0sMxUiHf8LNA7fXYyaYb7izO8rQp
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score
import joblib
from geopy.distance import geodesic

class DisasterAllocation:
    def __init__(self, camp_data, population_data, vehicle_data):
        self.camp_data = camp_data
        self.population_data = population_data
        self.vehicle_data = vehicle_data

    def disaster_distance(self, disaster_coords, camp_coords):
        return geodesic(camp_coords, disaster_coords).kilometers

    def relief_time(self, distance_km, vehicle_speed, emergency_factor=1.0):
        emergency_factor = max(0.5, min(emergency_factor, 2))
        return round((distance_km / vehicle_speed) * emergency_factor, 2)

    def display_distances_and_times(self, vehicle_data):
      disaster_coords = (
          self.vehicle_data["disaster_latitude"].iloc[0],
          self.vehicle_data["disaster_longitude"].iloc[0]
      )

      print("\n=== ðŸš¨ Distance and Time Report ===")
      for _, vehicle in vehicle_data.iterrows():
          camp_coords = (vehicle["latitude"], vehicle["longitude"])
          distance_km = self.disaster_distance(disaster_coords, camp_coords)
          estimated_time = self.relief_time(distance_km, vehicle["speed_kph"], emergency_factor=1.0)

          print(f"ðŸšš Vehicle ID: {vehicle['vehicle_id']}")
          print(f"ðŸ“ Distance to Disaster: {round(distance_km, 2)} km")
          print(f"â³ Estimated Time: {estimated_time} hours\n")

    def allocate_resources(self, demands):
        resources = ["medical_available", "food_available", "shelter_available"]
        allocation = []

        sorted_vehicles = self.vehicle_data.sort_values("capacity_kg", ascending=False)
        remaining_demand = {res: demands[res.replace("_available", "_demand")] for res in resources}
        total_demand = remaining_demand.copy()

        disaster_coords = (
            self.vehicle_data["disaster_latitude"].iloc[0],
            self.vehicle_data["disaster_longitude"].iloc[0]
        )

        for _, vehicle in sorted_vehicles.iterrows():
            vehicle_capacity = vehicle["capacity_kg"]
            vehicle_speed = vehicle["speed_kph"]
            vehicle_allocation = {}

            # Priority distribution: 50% Medical, 30% Food, 20% Shelter
            allocation_ratios = {
                "medical_available": 0.5,
                "food_available": 0.3,
                "shelter_available": 0.2
            }

            for resource in resources:
                allocated = min(vehicle_capacity * allocation_ratios[resource],
                                remaining_demand[resource])
                vehicle_allocation[resource] = int(allocated)
                remaining_demand[resource] -= allocated
                vehicle_capacity -= allocated

            while vehicle_capacity > 0:
                for resource in resources:
                    if remaining_demand[resource] > 0:
                        extra_allocation = min(vehicle_capacity, remaining_demand[resource])
                        vehicle_allocation[resource] += int(extra_allocation)
                        remaining_demand[resource] -= extra_allocation
                        vehicle_capacity -= extra_allocation
                        if vehicle_capacity <= 0:
                            break

            camp_coords = (vehicle["latitude"], vehicle["longitude"])
            distance_km = self.disaster_distance(disaster_coords, camp_coords)

            allocation.append({
                "vehicle_id": vehicle["vehicle_id"],
                "allocated_resources": vehicle_allocation,
                "distance_km": distance_km,
                "estimated_time_hr": self.relief_time(
                    distance_km,
                    vehicle_speed,
                    emergency_factor=1.0
                )
            })

            if all(value <= 0 for value in remaining_demand.values()):
                break

        report = []
        for resource in resources:
            if remaining_demand[resource] == 0:
                report.append(f"âœ… {resource.replace('_available', '').capitalize()} supplies fully met.")
            elif remaining_demand[resource] < total_demand[resource]:
                report.append(f"âš ï¸ {resource.replace('_available', '').capitalize()} supplies partially met.")
            else:
                report.append(f"âŒ {resource.replace('_available', '').capitalize()} supplies unmet.")

        print("\n=== âœ… Resource Allocation Report ===")
        for status in report:
            print(status)

        print(f"\nðŸšš Total Vehicles Used: {len(allocation)}")
        total_supplies_met = sum(total_demand[res] - remaining_demand[res] for res in resources)
        total_supplies_required = sum(total_demand.values())

        return allocation, remaining_demand

forecast_data = pd.read_csv("updated_forecast_dataset.csv")
vehicle_data = pd.read_csv("updated_ngo_resource_centers.csv")

forecast_data["literacy_rate"] = forecast_data["literate"] / forecast_data["population"]
forecast_data["worker_rate"] = forecast_data["workers"] / forecast_data["population"]
forecast_data["female_ratio"] = forecast_data["female"] / forecast_data["population"]

# Select Features and Labels
features = [
    "population", "male", "female", "literate", "workers",
    "male_workers", "female_workers", "literacy_rate", "worker_rate", "female_ratio"
]
targets = ["food_demand", "medical_demand", "shelter_demand"]

forecast_data["food_demand"] = forecast_data["population"] * 0.00035
forecast_data["medical_demand"] = forecast_data["population"] * 0.003
forecast_data["shelter_demand"] = forecast_data["population"] * 0.1

X = forecast_data[features]
y = forecast_data[targets]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluate Model
y_pred = model.predict(X_test)
print("Mean Absolute Error:", mean_absolute_error(y_test, y_pred))
print("RÂ² Score:", r2_score(y_test, y_pred))

joblib.dump(model, "resource_predictor_model.pkl")

test_district = forecast_data.iloc[5:6][features]
prediction = model.predict(test_district)

# Display Predictions
print(f"\nðŸ“ District: {forecast_data.iloc[5]['district_name']}, State: {forecast_data.iloc[5]['state_name']}")
print("Predicted Resource Needs:")
predicted_demands = {
    "food_demand": int(prediction[0][0]),
    "medical_demand": int(prediction[0][1]),
    "shelter_demand": int(prediction[0][2]),
}
print(predicted_demands)

allocation_system = DisasterAllocation(None, forecast_data, vehicle_data)
allocations, unmet_demands = allocation_system.allocate_resources(predicted_demands)
print("Allocations:", allocations)
print("Unmet Demands:", unmet_demands)

allocation = DisasterAllocation(camp_data=None, population_data=None, vehicle_data=vehicle_data)
allocation.display_distances_and_times(vehicle_data)